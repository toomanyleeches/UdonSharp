"use strict";(self.webpackChunkudon_sharp=self.webpackChunkudon_sharp||[]).push([[20],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return c}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=o.createContext({}),l=function(e){var t=o.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return o.createElement(d.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,d=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),c=r,m=u["".concat(d,".").concat(c)]||u[c]||h[c]||a;return n?o.createElement(m,i(i({ref:t},p),{},{components:n})):o.createElement(m,i({ref:t},p))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=u;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7040:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return d},default:function(){return c},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return h}});var o=n(7462),r=n(3366),a=(n(7294),n(3905)),i=["components"],s={id:"editor-scripting",title:"Editor Scripting",hide_title:!0},d="Editor Scripting",l={unversionedId:"editor-scripting",id:"editor-scripting",title:"Editor Scripting",description:"Overview",source:"@site/docs/Editor-Scripting.md",sourceDirName:".",slug:"/editor-scripting",permalink:"/editor-scripting",editUrl:"https://github.com/vrchat-community/UdonSharp/edit/master/Docs/Source/Editor-Scripting.md",tags:[],version:"current",frontMatter:{id:"editor-scripting",title:"Editor Scripting",hide_title:!0},sidebar:"mainSidebar",previous:{title:"Events",permalink:"/events"},next:{title:"Random Tips & Performance Pointers",permalink:"/random-tips-&-performance-pointers"}},p={},h=[{value:"Overview",id:"overview",level:2},{value:"Proxies",id:"proxies",level:2},{value:"Differences from regular C# behaviours and from U#",id:"differences-from-regular-c-behaviours-and-from-u",level:2},{value:"UdonSharpBehaviours are not UdonBehaviours",id:"udonsharpbehaviours-are-not-udonbehaviours",level:3},{value:"Proxy references are automatically handled only for UdonSharpBehaviour variables",id:"proxy-references-are-automatically-handled-only-for-udonsharpbehaviour-variables",level:3},{value:"Proxies are always disabled and should remain disabled",id:"proxies-are-always-disabled-and-should-remain-disabled",level:3},{value:"Making a custom inspector for your UdonSharpBehaviour",id:"making-a-custom-inspector-for-your-udonsharpbehaviour",level:2},{value:"Example inspector",id:"example-inspector",level:3},{value:"Using Handles",id:"using-handles",level:2},{value:"Using Gizmos",id:"using-gizmos",level:2},{value:"Non-inspector Editor Scripts",id:"non-inspector-editor-scripts",level:2},{value:"Adding an UdonSharpBehaviour",id:"adding-an-udonsharpbehaviour",level:3},{value:"Getting an existing UdonSharpBehaviour",id:"getting-an-existing-udonsharpbehaviour",level:3},{value:"Working with an UdonSharpBehaviour and modifying it",id:"working-with-an-udonsharpbehaviour-and-modifying-it",level:3},{value:"Destroying UdonSharpBehaviours",id:"destroying-udonsharpbehaviours",level:2}],u={toc:h};function c(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"editor-scripting"},"Editor Scripting"),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"As of UdonSharp version 0.18.0, an editor scripting API is included that allows you to make custom editors and editor scripts that interact with UdonSharpBehaviours the same as you would interact with the normal C# version of a behaviour."),(0,a.kt)("p",null,"For the most part the editor scripting API allows you to write C# code that just works the same as it would for the C# version of the script, but there are some things to keep in mind while working with the scripts. "),(0,a.kt)("p",null,"The basis for U# editor scripting is that UdonSharp will create instances of the C# version of your behaviour script and copy the fields from the UdonBehaviour version of the script to the C# 'proxy' behind the scenes. This proxy is what you'll be interacting with most of the time from editor scripts."),(0,a.kt)("h2",{id:"proxies"},"Proxies"),(0,a.kt)("p",null,"When you create an U# script, it is a completely valid C# script in addition to being valid in Udon when compiled with UdonSharp. Since it is a valid C# script, you are able to add it as a regular standalone component on GameObjects. Proxies are the C# version of your script that get added to GameObjects and linked to the Udon version of the script. When working with proxies, they can be thought of as similar to Unity's ",(0,a.kt)("inlineCode",{parentName:"p"},"SerializedObject")," type, where any changes you apply to the SerializedObject need to be applied to the original object, and any changes to the original object need to be updated on the serialized object."),(0,a.kt)("p",null,"Proxies are created on the same GameObject as their backing UdonBehaviour and are disabled. They should remain disabled at all times so Unity does not execute events on them. They are marked as hidden in the GameObject inspector so you cannot see them on the GameObject directly, but they are there. Proxies are also flagged to not be saved in the scene and not be saved in builds so you don't have to worry about them bloating package or download size since they only exist in the editor. "),(0,a.kt)("p",null,"You can execute methods on the proxies and have them work the same as running events on UdonBehaviours. The main thing you need to keep in mind is that in C# UdonSharpBehaviours are not UdonBehaviours, this is explained in further detail below."),(0,a.kt)("h2",{id:"differences-from-regular-c-behaviours-and-from-u"},"Differences from regular C# behaviours and from U#"),(0,a.kt)("h3",{id:"udonsharpbehaviours-are-not-udonbehaviours"},"UdonSharpBehaviours are not UdonBehaviours"),(0,a.kt)("p",null,"In UdonSharp code, it is possible to treat ",(0,a.kt)("strong",{parentName:"p"},"UdonBehaviours")," as ",(0,a.kt)("strong",{parentName:"p"},"UdonSharpBehaviours")," since they are represented as the same object internally. In C# this is not valid since UdonSharpBehaviours do not inherit from UdonBehaviours right now. This is done to prevent changes to UdonBehaviours by VRChat from breaking UdonSharpBehaviour scripts. This may change in the future when the UdonBehaviour API is more concrete."),(0,a.kt)("p",null,"Because of this, unless you want to allow people to plug in Udon behaviours built from the graph, you should always prefer to use ",(0,a.kt)("inlineCode",{parentName:"p"},"UdonSharpBehaviour")," as variable types instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"UdonBehaviour"),"."),(0,a.kt)("h3",{id:"proxy-references-are-automatically-handled-only-for-udonsharpbehaviour-variables"},"Proxy references are automatically handled only for UdonSharpBehaviour variables"),(0,a.kt)("p",null,"Only variable types for UdonSharpBehaviours will have their proxies handled automatically. When you reference another proxy behaviour in a proxy behaviour, its reference will automatically be converted to the UdonBehaviour reference by the proxy system. Because of this, variables that reference other ",(0,a.kt)("strong",{parentName:"p"},"UdonSharpBehaviours")," should be stored as the specific ",(0,a.kt)("strong",{parentName:"p"},"UdonSharpBehaviour")," type, or as the base ",(0,a.kt)("strong",{parentName:"p"},"UdonSharpBehaviour")," type if any ",(0,a.kt)("strong",{parentName:"p"},"UdonSharpBehaviour")," type can be stored in the variable. "),(0,a.kt)("p",null,"If you use variables of the type ",(0,a.kt)("inlineCode",{parentName:"p"},"UdonBehaviour"),", or if you store plain ",(0,a.kt)("inlineCode",{parentName:"p"},"Component")," references, or anything ambiguous at all, the proxy system will just populate the reference to the underlying UdonBehaviour. This is good if you want to allow references to graph assets since they do not fall under the proxy API since they don't have a C# equivalent. "),(0,a.kt)("p",null,"An important thing to keep in mind is that if you store references to the proxy behaviours directly in a variable that is not an UdonSharpBehaviour variable or some subclass of UdonSharpBehaviour, the reference will get cleared to null on build. For instance, if you want to have an ",(0,a.kt)("inlineCode",{parentName:"p"},"Component")," reference, make sure it's referencing the UdonBehaviour and not the proxy UdonSharpBehaviour."),(0,a.kt)("h3",{id:"proxies-are-always-disabled-and-should-remain-disabled"},"Proxies are always disabled and should remain disabled"),(0,a.kt)("p",null,"Proxies get disabled to prevent Unity from calling events and running the same logic twice during gameplay on them. You should never re-enable the proxy behaviours. Because proxy behaviours are disabled, if you run methods on the proxy behaviour that call things like GetComponentInChildren without telling it to get disabled behaviours as well, it will not return the proxies."),(0,a.kt)("h2",{id:"making-a-custom-inspector-for-your-udonsharpbehaviour"},"Making a custom inspector for your UdonSharpBehaviour"),(0,a.kt)("p",null,"When making custom editors for UdonSharpBehaviours, most things are abstracted to the point that it's exactly like making a normal custom inspector. You just need to make a class that inherits from ",(0,a.kt)("inlineCode",{parentName:"p"},"Editor")," and add the ",(0,a.kt)("inlineCode",{parentName:"p"},"CustomEditor")," attribute with the type of your UdonSharpBehaviour."),(0,a.kt)("p",null,"When making any custom editors for C# scripts, not just UdonSharp scripts, you must make sure that the editor code you write will not be part of game builds since it will make worlds fail to build. In Unity you have two main ways to make sure code doesn't get included in the world build. The first is to place your inspector scripts inside a folder named ",(0,a.kt)("strong",{parentName:"p"},"Editor"),", this will prevent that code from getting included in the build. The other way is to wrap your code in a check for the preprocessor definition ",(0,a.kt)("inlineCode",{parentName:"p"},"UNITY_EDITOR"),", for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"#if UNITY_EDITOR\n[CustomEditor(typeof(CustomInspectorBehaviour))]\npublic class CustomInspectorEditor : Editor\n{\n    ...\n}\n#endif\n")),(0,a.kt)("p",null,"Using statements for editor only namespaces like ",(0,a.kt)("inlineCode",{parentName:"p"},"UnityEditor")," will also need to be wrapped in the same ",(0,a.kt)("inlineCode",{parentName:"p"},"UNITY_EDITOR")," check"),(0,a.kt)("p",null,"If you want to write your inspector in the same script file as your UdonSharpBehaviour script, you will need to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"COMPILER_UDONSHARP")," preprocessor definition to prevent UdonSharp from parsing the editor only code. Using the above example with this it would look like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"public class CustomInspectorBehaviour : UdonSharpBehaviour \n{\n    ...\n}\n\n#if !COMPILER_UDONSHARP && UNITY_EDITOR\n[CustomEditor(typeof(CustomInspectorBehaviour))]\npublic class CustomInspectorEditor : Editor\n{\n    ...\n}\n#endif\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f The ",(0,a.kt)("inlineCode",{parentName:"p"},"COMPILER_UDONSHARP")," preprocessor definition will only ever be true inside the same script as the UdonSharpBehaviour, external scripts that do not contain an UdonSharpBehaviour and are not connected to an UdonSharpProgramAsset will never have ",(0,a.kt)("inlineCode",{parentName:"p"},"COMPILER_UDONSHARP")," marked true")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Do not use ",(0,a.kt)("inlineCode",{parentName:"p"},"COMPILER_UDONSHARP")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"UNITY_EDITOR")," to conditionally remove or add fields to UdonSharpBehaviours, this will result in unexpected behavior")),(0,a.kt)("p",null,"When you make a custom inspector, you should always start the OnInspectorGUI with "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"if (UdonSharpGUI.DrawDefaultUdonSharpBehaviourHeader(target)) return;\n")),(0,a.kt)("p",null,"This handles drawing the default UdonSharp header that contains the convert to behaviour button for C# scripts, the syncing settings, the interact settings, and the utilities. You can draw each individual section as well, look at the implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"DrawDefaultUdonSharpBehaviourHeader()")," for what you can draw."),(0,a.kt)("h3",{id:"example-inspector"},"Example inspector"),(0,a.kt)("p",null,"This example is included with UdonSharp"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},'using UnityEngine;\nusing VRC.SDK3.Components;\nusing VRC.SDKBase;\nusing VRC.Udon;\n\n#if !COMPILER_UDONSHARP && UNITY_EDITOR // These using statements must be wrapped in this check to prevent issues on builds\nusing UnityEditor;\nusing UdonSharpEditor;\n#endif\n\nnamespace UdonSharp.Examples.Inspectors\n{\n    /// <summary>\n    /// Example behaviour that has a custom inspector\n    /// </summary>\n    public class CustomInspectorBehaviour : UdonSharpBehaviour \n    {\n        public string stringVal;\n\n        private void Update()\n        {\n            Debug.Log($"CustomInspectorBehaviour: {stringVal}");\n        }\n    }\n\n    // Editor scripts must be wrapped in a UNITY_EDITOR check to prevent issues while uploading worlds. The !COMPILER_UDONSHARP check prevents UdonSharp from throwing errors about unsupported code here.\n#if !COMPILER_UDONSHARP && UNITY_EDITOR \n    [CustomEditor(typeof(CustomInspectorBehaviour))]\n    public class CustomInspectorEditor : Editor\n    {\n        public override void OnInspectorGUI()\n        {\n            // Draws the default convert to UdonBehaviour button, program asset field, sync settings, etc.\n            if (UdonSharpGUI.DrawDefaultUdonSharpBehaviourHeader(target)) return;\n\n            CustomInspectorBehaviour inspectorBehaviour = (CustomInspectorBehaviour)target;\n\n            EditorGUI.BeginChangeCheck();\n\n            // A simple string field modification with Undo handling\n            string newStrVal = EditorGUILayout.TextField("String Val", inspectorBehaviour.stringVal);\n\n            if (EditorGUI.EndChangeCheck())\n            {\n                Undo.RecordObject(inspectorBehaviour, "Modify string val");\n\n                inspectorBehaviour.stringVal = newStrVal;\n            }\n        }\n    }\n#endif\n}\n')),(0,a.kt)("h2",{id:"using-handles"},"Using ",(0,a.kt)("a",{parentName:"h2",href:"https://docs.unity3d.com/ScriptReference/Handles.html"},"Handles")),(0,a.kt)("p",null,"This works the same as making a custom inspector GUI, everything is handled automatically for the most part. You just use the OnSceneGUI event on the Editor and it should work as expected."),(0,a.kt)("h2",{id:"using-gizmos"},"Using ",(0,a.kt)("a",{parentName:"h2",href:"https://docs.unity3d.com/ScriptReference/Gizmos.html"},"Gizmos")),(0,a.kt)("p",null,"Gizmos need a little special handling to work as you'd expect. One of the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/vrchat-community/UdonSharp/blob/master/Assets/UdonSharp/Examples/CustomInspectors/CustomInspectorChildBehaviour.cs#L33"},"example scripts")," makes use of Gizmos. For Gizmos you should wrap the OnDrawGizmos events themselves in the same ",(0,a.kt)("inlineCode",{parentName:"p"},"#if !COMPILER_UDONSHARP && UNITY_EDITOR")," check that we wrapped the editor in, and the ",(0,a.kt)("strong",{parentName:"p"},"OnDrawGizmos")," and ",(0,a.kt)("strong",{parentName:"p"},"OnDrawGizmosSelected")," events should go on the behaviour itself."),(0,a.kt)("p",null,"Gizmos draw using the proxy behaviour that gets attached to all UdonBehaviours with UdonSharpProgramAssets. They do not get executed through Udon since Udon does not run UdonBehaviours when not in play mode. The Gizmos events are not managed by UdonSharp so you need to do a little to make sure your proxy behaviour is up to date. To do this, call either of these two methods, both do the same thing, ",(0,a.kt)("inlineCode",{parentName:"p"},"UpdateProxy")," is just made to emulate the Unity API's for serialized objects."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"// Call this\nUdonSharpEditorUtility.CopyUdonToProxy(this);\n// Or this\nthis.UpdateProxy();\n// Do not call both since you'd be doing redundant work\n")),(0,a.kt)("p",null,"You can see an example of this in the example script linked above."),(0,a.kt)("h2",{id:"non-inspector-editor-scripts"},"Non-inspector Editor Scripts"),(0,a.kt)("p",null,"When you are creating editor scripts that create/delete/modify UdonSharpBehaviours, you need to manage updating the proxy and applying its modifications yourself. "),(0,a.kt)("h3",{id:"adding-an-udonsharpbehaviour"},"Adding an UdonSharpBehaviour"),(0,a.kt)("p",null,"Adding a new UdonSharpBehaviour is as simple as getting the GameObject you want to attach it to and calling .",(0,a.kt)("inlineCode",{parentName:"p"},"AddUdonSharpComponent<T>()")," on it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"GameObject targetGameObject = ... // Get some game object from somewhere here\nMyComponentType newComponent = targetGameObject.AddUdonSharpComponent<MyComponentType>();\n")),(0,a.kt)("p",null,"Now newComponent is a valid UdonSharpBehaviour proxy of your component type MyComponentType. You can interact with this like any other C# component from the editor script. If you want the component creation to be undoable, instead use:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"GameObject targetGameObject = ... // Get some game object from somewhere here\nMyComponentType newComponent = UdonSharpUndo.AddComponent<MyComponentType>(targetGameObject);\n")),(0,a.kt)("h3",{id:"getting-an-existing-udonsharpbehaviour"},"Getting an existing UdonSharpBehaviour"),(0,a.kt)("p",null,"UdonSharp has equivalents for GetComponent(s) defined as extension methods to GameObject. When you are working with editor scripts, instead of calling ",(0,a.kt)("inlineCode",{parentName:"p"},"GetComponent<T>()"),", you should call its equivalent ",(0,a.kt)("inlineCode",{parentName:"p"},"GetUdonSharpComponent<T>()"),"."),(0,a.kt)("p",null,"In order to get all UdonSharpBehaviours of the type ",(0,a.kt)("inlineCode",{parentName:"p"},"MyComponentType")," on children of a GameObject, you would do the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"GameObject sourceGameObject = ... // Get some game object from somewhere here\nMyComponentType[] myComponents = sourceGameObject.GetUdonSharpComponentsInChildren<MyComponentType>();\n")),(0,a.kt)("h3",{id:"working-with-an-udonsharpbehaviour-and-modifying-it"},"Working with an UdonSharpBehaviour and modifying it"),(0,a.kt)("p",null,"Once you have an UdonSharpBehaviour to work with, you will need to handle making sure any modifications to the proxy get propagated to Udon."),(0,a.kt)("p",null,"If Udon is making any changes to the behaviour, the behaviour should get updated if you are using GetUdonSharpComponent(s) since those will automatically update the behaviour. If you store a reference to the behaviour, you will need to update it yourself. This can be done by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"UpdateProxy()")," on the behaviour."),(0,a.kt)("p",null,"Once you have modified your behaviour, you must apply the modifications on the proxy behaviour to Udon. This can be done by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"ApplyProxyModifications()")," on the behaviour."),(0,a.kt)("p",null,"You can think of this as being similar to working with Unity SerializedObjects."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"MyComponentType myComponent = ...\n// We only need to update the proxy if we storing some persistent reference to it\nmyComponent.UpdateProxy();\n// Add 5 to a `float` on our behaviour\nmyComponent.myFloatField += 5f;\n// Apply the changes to myComponent to the Udon copy of it\nmyComponent.ApplyProxyModifications();\n")),(0,a.kt)("h2",{id:"destroying-udonsharpbehaviours"},"Destroying UdonSharpBehaviours"),(0,a.kt)("p",null,"You should use the UdonSharpEditorUtility.DestroyImmediate() method to destroy UdonSharpBehaviours and delete their underlying UdonBehaviour."))}c.isMDXComponent=!0}}]);